{"version":3,"sources":["webpack:///webpack/bootstrap d5014c794e7b2347e5d5","webpack:///./src/client.ts","webpack:///./src/Dish.ts","webpack:///./src/Player.ts","webpack:///./src/Germ.ts","webpack:///./src/Replicator.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA,mBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,iCAAiC;AACnD,kBAAiB,gCAAgC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,wCAAuC,iCAAiC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0FAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,wBAAuB,WAAW;AAClC;AACA;AACA;AACA","file":"dist/client.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d5014c794e7b2347e5d5","\"use strict\";\r\nconst Dish_1 = require(\"./Dish\");\r\nconst Player_1 = require(\"./Player\");\r\nconst Replicator_1 = require(\"./Replicator\");\r\nlet conf = {\r\n    germsPerLayer: 15,\r\n    layers: 6\r\n}, germOptions = {\r\n    defaultColor: \"yellow\",\r\n    maxLayer: conf.layers - 1,\r\n    minRadius: 5,\r\n    maxRadius: window.innerHeight / 8,\r\n    maxSpeed: 6\r\n}, playerOptions = {\r\n    defaultColor: \"white\",\r\n    maxLayer: conf.layers - 1,\r\n    minRadius: 40,\r\n    maxRadius: window.innerHeight / 8,\r\n    maxSpeed: 12\r\n}, player = new Player_1.Player(playerOptions), dish = new Dish_1.Dish({\r\n    color: \"black\",\r\n    elementSelector: \"body\",\r\n    layers: conf.layers,\r\n    player: player\r\n});\r\nReplicator_1.Replicator\r\n    .generateGerms(conf.germsPerLayer * conf.layers, germOptions)\r\n    .forEach(g => dish.append(g));\r\n// Prerun to randomize a bit\r\n// for (let i = 0; i < 15000; i++) dish.run();\r\n// let tick = 0;\r\nlet run = () => {\r\n    // if (tick++ % 2) dish.run();\r\n    dish.run();\r\n    dish.render();\r\n    requestAnimationFrame(run);\r\n};\r\nrequestAnimationFrame(run);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/client.ts\n// module id = 0\n// module chunks = 0","\"use strict\";\r\nclass Dish {\r\n    constructor(options) {\r\n        this.keyboard = {};\r\n        this.keyboardCodes = {};\r\n        this.options = options;\r\n        this.germs = [];\r\n        for (let i = 0; i < this.options.layers; i++)\r\n            this.germs.push([]);\r\n        this.append(this.options.player);\r\n        this.setupCanvas();\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(\"keydown\", this.handleKeydown.bind(this));\r\n        window.addEventListener(\"keyup\", this.handleKeyup.bind(this));\r\n        window.addEventListener(\"resize\", this.handleResize.bind(this));\r\n    }\r\n    handleKeydown(event) {\r\n        this.keyboard[event.key] = true;\r\n        this.keyboardCodes[event.keyCode] = true;\r\n    }\r\n    handleKeyup(event) {\r\n        this.keyboard[event.key] = false;\r\n        this.keyboardCodes[event.keyCode] = false;\r\n    }\r\n    handleResize(event) {\r\n        this.canvas.width = this.el.clientWidth;\r\n        this.canvas.height = this.el.clientHeight;\r\n    }\r\n    setupCanvas() {\r\n        this.el = document.querySelector(this.options.elementSelector);\r\n        this.canvas = document.createElement(\"canvas\");\r\n        this.el.appendChild(this.canvas);\r\n        this.canvas.width = this.el.clientWidth;\r\n        this.canvas.height = this.el.clientHeight;\r\n        this.canvasContext = this.canvas.getContext('2d');\r\n    }\r\n    get height() { return this.canvas.clientHeight; }\r\n    get width() { return this.canvas.clientWidth; }\r\n    append(germ) {\r\n        this.germs[germ.z].push(germ);\r\n    }\r\n    clearCanvas() {\r\n        this.canvasContext.fillStyle = this.options.color || \"white\";\r\n        this.canvasContext.fillRect(0, 0, this.width, this.height);\r\n    }\r\n    getGermScale(germ) {\r\n        return (this.options.player.z + 1) / (germ.z + 1);\r\n    }\r\n    handleCollision(g1, g2) {\r\n        // TODO: ADD TO OPTIONS\r\n        if (g1.radius > g2.radius || (g1.radius === g2.radius && g1 === this.options.player)) {\r\n            g1.radius += 1;\r\n            g2.radius -= 1;\r\n            if (g2.radius <= 0)\r\n                g2.reset(this);\r\n        }\r\n        //  else {\r\n        //     g1.radius -= 1;\r\n        //     g2.radius += 1;\r\n        //     if (g1.radius <= 0) g1.reset(this);\r\n        // }\r\n    }\r\n    isGermVisible(germ, scale) {\r\n        return germ === this.options.player || ((germ.x - germ.radius) * scale < this.width &&\r\n            (germ.x + germ.radius) * scale > 0 &&\r\n            (germ.y - germ.radius) * scale < this.height &&\r\n            (germ.y + germ.radius) * scale > 0);\r\n    }\r\n    isKeydown(key) {\r\n        // TODO: HANDLE STRING ARRAY\r\n        switch (typeof key) {\r\n            case \"number\": return !!this.keyboardCodes[key];\r\n            case \"string\": return !!this.keyboard[key];\r\n            default: return key.some(c => this.keyboard[c]);\r\n        }\r\n    }\r\n    render() {\r\n        // Clear the canvas\r\n        this.clearCanvas();\r\n        // Render germs\r\n        this.germs\r\n            .forEach((layer, layerIndex) => layer.forEach(g => {\r\n            // Scale by z-distance to player and don't render offscreen\r\n            const scale = this.getGermScale(g), visible = this.isGermVisible(g, scale);\r\n            // Render the germ\r\n            if (visible)\r\n                g.render(this.canvasContext, scale, scale === 1 ? 1 : scale * 0.2);\r\n        }));\r\n        // Render UI\r\n        this.canvasContext.font = \"20px Arial\";\r\n        this.canvasContext.fillStyle = \"red\";\r\n        this.canvasContext.fillText(`${this.options.player.z.toString()}`, 20, 40);\r\n    }\r\n    run() {\r\n        // Update germs\r\n        this.germs\r\n            .forEach((layer, layerIndex) => layer.forEach(g => {\r\n            // Scale by z-distance\r\n            const scale = this.getGermScale(g);\r\n            // Update position\r\n            g.x += g.xSpeed;\r\n            g.y += g.ySpeed;\r\n            // Handle collisions\r\n            if (g.radius <= g.options.maxRadius)\r\n                layer.forEach(g2 => g.collides(g2) && this.handleCollision(g, g2));\r\n            // Reset when offscreen\r\n            if (this.shouldGermReset(g, scale))\r\n                g.reset(this, scale);\r\n            // Handle layer changes\r\n            if (g.z !== layerIndex) {\r\n                layer.splice(layer.indexOf(g), 1);\r\n                this.germs[g.z].push(g);\r\n            }\r\n            // Run the germ\r\n            g.run(this);\r\n        }));\r\n    }\r\n    shouldGermReset(germ, scale) {\r\n        // TODO: VERIFY SCALING LOGIC\r\n        return germ.radius * scale <= 5 ||\r\n            (germ.x * scale) + (germ.radius * scale) < 0 ||\r\n            ((germ.y * scale) + (germ.radius * scale) < 0 && germ.ySpeed <= 0) ||\r\n            ((germ.y * scale) - (germ.radius * scale) > this.height && germ.ySpeed >= 0); // Top edge below bottom of screen and ySpeed > 0\r\n    }\r\n    size() {\r\n        let c = 0;\r\n        this.germs.forEach(layer => c += layer.length);\r\n        return c;\r\n    }\r\n}\r\nexports.Dish = Dish;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Dish.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\r\nconst Germ_1 = require(\"./Germ\");\r\nclass Player extends Germ_1.Germ {\r\n    constructor(options) {\r\n        super(options);\r\n        this.z = 2; //options.maxLayer / 2;\r\n    }\r\n    reset(dish) {\r\n        if (this.radius < this.options.minRadius && this.z > 0)\r\n            this.z--;\r\n        if (this.radius > this.options.maxRadius && this.z < this.options.maxLayer)\r\n            this.z++;\r\n        this.radius = this.options.minRadius;\r\n        this.warp(this.radius + 1, dish.height / 2);\r\n    }\r\n    run(dish) {\r\n        if (this.radius < this.options.minRadius ||\r\n            this.radius > this.options.maxRadius)\r\n            this.reset(dish);\r\n        if (dish.isKeydown([\"w\"]))\r\n            this.y -= this.options.maxSpeed;\r\n        if (dish.isKeydown([\"a\"]))\r\n            this.x -= this.options.maxSpeed;\r\n        if (dish.isKeydown([\"s\"]))\r\n            this.y += this.options.maxSpeed;\r\n        if (dish.isKeydown([\"d\"]))\r\n            this.x += this.options.maxSpeed;\r\n        if (this.left < 0)\r\n            this.left = 0;\r\n        if (this.right > dish.width)\r\n            this.right = dish.width;\r\n        if (this.top < 0)\r\n            this.top = 0;\r\n        if (this.bottom > dish.height)\r\n            this.bottom = dish.height;\r\n    }\r\n}\r\nexports.Player = Player;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Player.ts\n// module id = 2\n// module chunks = 0","\"use strict\";\r\nclass Germ {\r\n    constructor(options) {\r\n        this.options = options;\r\n        this.color = this.options.defaultColor;\r\n        this.radius = 0;\r\n        this.x = 0;\r\n        this.xSpeed = 0;\r\n        this.y = 0;\r\n        this.ySpeed = 0;\r\n        this.z = Math.floor(Math.random() * this.options.maxLayer);\r\n    }\r\n    get bottom() {\r\n        return this.y + this.radius;\r\n    }\r\n    set bottom(v) {\r\n        this.y = v - this.radius;\r\n    }\r\n    get left() {\r\n        return this.x - this.radius;\r\n    }\r\n    set left(v) {\r\n        this.x = v + this.radius;\r\n    }\r\n    get right() {\r\n        return this.x + this.radius;\r\n    }\r\n    set right(v) {\r\n        this.x = v - this.radius;\r\n    }\r\n    get top() {\r\n        return this.y - this.radius;\r\n    }\r\n    set top(v) {\r\n        this.y = v + this.radius;\r\n    }\r\n    collides(germ) {\r\n        return this !== germ &&\r\n            this.z === germ.z &&\r\n            // this.radius <= this.options.maxRadius &&\r\n            // germ.radius <= germ.options.maxRadius &&\r\n            this.distanceToPoint(germ.x, germ.y) < (this.radius + germ.radius);\r\n    }\r\n    distanceToPoint(x, y) {\r\n        return Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n    }\r\n    render(context, scale = 1, opacity = 1) {\r\n        // TODO: MOVE TO OPTIONS\r\n        if (this.radius * scale < 5)\r\n            return;\r\n        context.globalAlpha = opacity;\r\n        context.beginPath();\r\n        context.arc(this.x * scale, this.y * scale, this.radius * scale, 0, 2 * Math.PI, false);\r\n        context.fillStyle = this.color;\r\n        context.fill();\r\n        context.lineWidth = 5 * scale; // TODO: MOVE TO OPTIONS\r\n        context.strokeStyle = '#003300'; // TODO: MOVE TO OPTIONS\r\n        context.stroke();\r\n        context.globalAlpha = 1;\r\n    }\r\n    /**\r\n     * Randomize the germ's radius, move it offscreen\r\n     * and set its speed to intersect with the dish.\r\n     * If too large or small update the layer as well\r\n     */\r\n    reset(dish, scale = 1) {\r\n        // Update the layer if too large or small, randomize \r\n        // only if out of range\r\n        if (this.radius < this.options.minRadius)\r\n            this.z--;\r\n        if (this.radius > this.options.maxRadius)\r\n            this.z++;\r\n        this.z = this.z > this.options.maxLayer || this.z < 0 ?\r\n            this.options.maxLayer - 1 :\r\n            this.z;\r\n        // Randomize radius\r\n        this.radius = this.options.minRadius + (Math.random() * (this.options.maxRadius - this.options.minRadius) * 0.5);\r\n        // Randomize location\r\n        // TODO: account correctly for scale when determining new location\r\n        this.x = (dish.width / scale) + this.radius + (Math.random() * dish.width);\r\n        this.y = Math.round(Math.random() * dish.height * 3 / scale) - (dish.height / scale);\r\n        this.xSpeed = -Math.round(Math.random() * this.options.maxSpeed);\r\n        this.ySpeed = Math.floor(Math.random() * this.options.maxSpeed * 2) - this.options.maxSpeed;\r\n    }\r\n    run(dish) { }\r\n    warp(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z !== undefined ? z : this.z;\r\n    }\r\n}\r\nexports.Germ = Germ;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Germ.ts\n// module id = 3\n// module chunks = 0","\"use strict\";\r\nconst Germ_1 = require(\"./Germ\");\r\nexports.Replicator = {\r\n    generateGerm(options) {\r\n        let g = new Germ_1.Germ(options);\r\n        return g;\r\n    },\r\n    generateGerms(count, options) {\r\n        let germs = [];\r\n        for (let i = 0; i < count; i++)\r\n            germs.push(exports.Replicator.generateGerm(options));\r\n        return germs;\r\n    }\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Replicator.ts\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}